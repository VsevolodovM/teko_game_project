// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tak.proto

package tak

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Direction translated to x/y axis direction.
type Direction int32

const (
	Direction_NORTH Direction = 0
	Direction_EAST  Direction = 1
	Direction_SOUTH Direction = 2
	Direction_WEST  Direction = 3
)

var Direction_name = map[int32]string{
	0: "NORTH",
	1: "EAST",
	2: "SOUTH",
	3: "WEST",
}

var Direction_value = map[string]int32{
	"NORTH": 0,
	"EAST":  1,
	"SOUTH": 2,
	"WEST":  3,
}

func (x Direction) String() string {
	return proto.EnumName(Direction_name, int32(x))
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{0}
}

// Type of the stone to play.
type PieceType int32

const (
	PieceType_FLAT_STONE     PieceType = 0
	PieceType_STANDING_STONE PieceType = 1
	PieceType_CAPSTONE       PieceType = 2
)

var PieceType_name = map[int32]string{
	0: "FLAT_STONE",
	1: "STANDING_STONE",
	2: "CAPSTONE",
}

var PieceType_value = map[string]int32{
	"FLAT_STONE":     0,
	"STANDING_STONE": 1,
	"CAPSTONE":       2,
}

func (x PieceType) String() string {
	return proto.EnumName(PieceType_name, int32(x))
}

func (PieceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{1}
}

// The GameParameter packet defines the game-specific start settings.
type GameParameter struct {
	BoardLength          uint32   `protobuf:"varint,1,opt,name=board_length,json=boardLength,proto3" json:"board_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameParameter) Reset()         { *m = GameParameter{} }
func (m *GameParameter) String() string { return proto.CompactTextString(m) }
func (*GameParameter) ProtoMessage()    {}
func (*GameParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{0}
}

func (m *GameParameter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GameParameter.Unmarshal(m, b)
}
func (m *GameParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GameParameter.Marshal(b, m, deterministic)
}
func (m *GameParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameParameter.Merge(m, src)
}
func (m *GameParameter) XXX_Size() int {
	return xxx_messageInfo_GameParameter.Size(m)
}
func (m *GameParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_GameParameter.DiscardUnknown(m)
}

var xxx_messageInfo_GameParameter proto.InternalMessageInfo

func (m *GameParameter) GetBoardLength() uint32 {
	if m != nil {
		return m.BoardLength
	}
	return 0
}

// The player places a stone/piece.
type PlaceAction struct {
	Piece                PieceType `protobuf:"varint,1,opt,name=piece,proto3,enum=tak.PieceType" json:"piece,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PlaceAction) Reset()         { *m = PlaceAction{} }
func (m *PlaceAction) String() string { return proto.CompactTextString(m) }
func (*PlaceAction) ProtoMessage()    {}
func (*PlaceAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{1}
}

func (m *PlaceAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceAction.Unmarshal(m, b)
}
func (m *PlaceAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceAction.Marshal(b, m, deterministic)
}
func (m *PlaceAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceAction.Merge(m, src)
}
func (m *PlaceAction) XXX_Size() int {
	return xxx_messageInfo_PlaceAction.Size(m)
}
func (m *PlaceAction) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceAction.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceAction proto.InternalMessageInfo

func (m *PlaceAction) GetPiece() PieceType {
	if m != nil {
		return m.Piece
	}
	return PieceType_FLAT_STONE
}

// The player moves a pile.
type MoveAction struct {
	Direction Direction `protobuf:"varint,1,opt,name=direction,proto3,enum=tak.Direction" json:"direction,omitempty"`
	// List of stones to drop.
	// Stones are removed from the origin pile at (x|y) and dropped in the given direction.
	// Lower indices are closer to the origin pile.
	//
	// Example:
	//   Lets assume we have a 6x1 snippet of the board (n=6), with 6 flat stones of player 1 on position (1|0).
	//   We want to drop 1 flat stone at position (2|0), 2 flat stones at (3|0) and 3 flat stones at (4|0).
	//
	//   Initial board (top left is (0|0)):
	//    --- --- --- --- --- ---
	//   |   | 6 |   |   |   |   |
	//    --- --- --- --- --- ---
	//
	//   To achieve this move, a MoveAction has to look like this:
	//   - direction := EAST
	//   - drops := [1, 2, 3]
	//
	//   The resulting board will look like this:
	//    --- --- --- --- --- ---
	//   |   |   | 1 | 2 | 3 |   |
	//    --- --- --- --- --- ---
	//
	Drops                []uint32 `protobuf:"varint,2,rep,packed,name=drops,proto3" json:"drops,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MoveAction) Reset()         { *m = MoveAction{} }
func (m *MoveAction) String() string { return proto.CompactTextString(m) }
func (*MoveAction) ProtoMessage()    {}
func (*MoveAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{2}
}

func (m *MoveAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MoveAction.Unmarshal(m, b)
}
func (m *MoveAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MoveAction.Marshal(b, m, deterministic)
}
func (m *MoveAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveAction.Merge(m, src)
}
func (m *MoveAction) XXX_Size() int {
	return xxx_messageInfo_MoveAction.Size(m)
}
func (m *MoveAction) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveAction.DiscardUnknown(m)
}

var xxx_messageInfo_MoveAction proto.InternalMessageInfo

func (m *MoveAction) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return Direction_NORTH
}

func (m *MoveAction) GetDrops() []uint32 {
	if m != nil {
		return m.Drops
	}
	return nil
}

// The GameTurn packet defines the players action for this turn.
type GameTurn struct {
	X uint32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y uint32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	// Types that are valid to be assigned to Action:
	//	*GameTurn_Place
	//	*GameTurn_Move
	Action               isGameTurn_Action `protobuf_oneof:"Action"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GameTurn) Reset()         { *m = GameTurn{} }
func (m *GameTurn) String() string { return proto.CompactTextString(m) }
func (*GameTurn) ProtoMessage()    {}
func (*GameTurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{3}
}

func (m *GameTurn) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GameTurn.Unmarshal(m, b)
}
func (m *GameTurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GameTurn.Marshal(b, m, deterministic)
}
func (m *GameTurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameTurn.Merge(m, src)
}
func (m *GameTurn) XXX_Size() int {
	return xxx_messageInfo_GameTurn.Size(m)
}
func (m *GameTurn) XXX_DiscardUnknown() {
	xxx_messageInfo_GameTurn.DiscardUnknown(m)
}

var xxx_messageInfo_GameTurn proto.InternalMessageInfo

func (m *GameTurn) GetX() uint32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *GameTurn) GetY() uint32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type isGameTurn_Action interface {
	isGameTurn_Action()
}

type GameTurn_Place struct {
	Place *PlaceAction `protobuf:"bytes,3,opt,name=place,proto3,oneof"`
}

type GameTurn_Move struct {
	Move *MoveAction `protobuf:"bytes,4,opt,name=move,proto3,oneof"`
}

func (*GameTurn_Place) isGameTurn_Action() {}

func (*GameTurn_Move) isGameTurn_Action() {}

func (m *GameTurn) GetAction() isGameTurn_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *GameTurn) GetPlace() *PlaceAction {
	if x, ok := m.GetAction().(*GameTurn_Place); ok {
		return x.Place
	}
	return nil
}

func (m *GameTurn) GetMove() *MoveAction {
	if x, ok := m.GetAction().(*GameTurn_Move); ok {
		return x.Move
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GameTurn) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GameTurn_Place)(nil),
		(*GameTurn_Move)(nil),
	}
}

// A piece is some stone with an owner.
type Piece struct {
	Type PieceType `protobuf:"varint,1,opt,name=type,proto3,enum=tak.PieceType" json:"type,omitempty"`
	// Owner of the stone.
	// Conveniently, false maps to 0 (index first player), true to 1 (index second player).
	SecondPlayerOwned    bool     `protobuf:"varint,2,opt,name=second_player_owned,json=secondPlayerOwned,proto3" json:"second_player_owned,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Piece) Reset()         { *m = Piece{} }
func (m *Piece) String() string { return proto.CompactTextString(m) }
func (*Piece) ProtoMessage()    {}
func (*Piece) Descriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{4}
}

func (m *Piece) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Piece.Unmarshal(m, b)
}
func (m *Piece) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Piece.Marshal(b, m, deterministic)
}
func (m *Piece) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Piece.Merge(m, src)
}
func (m *Piece) XXX_Size() int {
	return xxx_messageInfo_Piece.Size(m)
}
func (m *Piece) XXX_DiscardUnknown() {
	xxx_messageInfo_Piece.DiscardUnknown(m)
}

var xxx_messageInfo_Piece proto.InternalMessageInfo

func (m *Piece) GetType() PieceType {
	if m != nil {
		return m.Type
	}
	return PieceType_FLAT_STONE
}

func (m *Piece) GetSecondPlayerOwned() bool {
	if m != nil {
		return m.SecondPlayerOwned
	}
	return false
}

// A pile of stones/pieces.
type Pile struct {
	// List of pieces on this pile.
	// The lowest index is the stone at the bottom of the pile.
	// The highest index is the stone at the top of the pile.
	// May be empty, indicating no one owns this field.
	Pieces               []*Piece `protobuf:"bytes,1,rep,name=pieces,proto3" json:"pieces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pile) Reset()         { *m = Pile{} }
func (m *Pile) String() string { return proto.CompactTextString(m) }
func (*Pile) ProtoMessage()    {}
func (*Pile) Descriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{5}
}

func (m *Pile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pile.Unmarshal(m, b)
}
func (m *Pile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pile.Marshal(b, m, deterministic)
}
func (m *Pile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pile.Merge(m, src)
}
func (m *Pile) XXX_Size() int {
	return xxx_messageInfo_Pile.Size(m)
}
func (m *Pile) XXX_DiscardUnknown() {
	xxx_messageInfo_Pile.DiscardUnknown(m)
}

var xxx_messageInfo_Pile proto.InternalMessageInfo

func (m *Pile) GetPieces() []*Piece {
	if m != nil {
		return m.Pieces
	}
	return nil
}

// The GameState packet defines the current board state of the match.
type GameState struct {
	BoardLength uint32 `protobuf:"varint,1,opt,name=board_length,json=boardLength,proto3" json:"board_length,omitempty"`
	// Remaining stones of both players.
	// Index 0 is the first player, index 1 is the second player.
	RemainingStones []uint32 `protobuf:"varint,2,rep,packed,name=remaining_stones,json=remainingStones,proto3" json:"remaining_stones,omitempty"`
	// Remaining capstones of both players.
	// Index 0 is the first player, index 1 is the second player.
	RemainingCapstones []uint32 `protobuf:"varint,3,rep,packed,name=remaining_capstones,json=remainingCapstones,proto3" json:"remaining_capstones,omitempty"`
	// Flattened list of fields (both non-/empty piles) on the board, resulting in n² fields.
	// The top left of the board corresponds to position (0|0).
	// Fields are added row-wise. Index 0 is position (0|0).
	//
	// Example:
	// - board_length := 3.
	// - board := [Pile(0|0), Pile(1|0), Pile(2|0),
	//             Pile(0|1), Pile(1|1), Pile(2|1),
	//             Pile(0|2), Pile(1|2), Pile(2|2)]
	Board                []*Pile  `protobuf:"bytes,4,rep,name=board,proto3" json:"board,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameState) Reset()         { *m = GameState{} }
func (m *GameState) String() string { return proto.CompactTextString(m) }
func (*GameState) ProtoMessage()    {}
func (*GameState) Descriptor() ([]byte, []int) {
	return fileDescriptor_28c71ac9511ea633, []int{6}
}

func (m *GameState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GameState.Unmarshal(m, b)
}
func (m *GameState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GameState.Marshal(b, m, deterministic)
}
func (m *GameState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameState.Merge(m, src)
}
func (m *GameState) XXX_Size() int {
	return xxx_messageInfo_GameState.Size(m)
}
func (m *GameState) XXX_DiscardUnknown() {
	xxx_messageInfo_GameState.DiscardUnknown(m)
}

var xxx_messageInfo_GameState proto.InternalMessageInfo

func (m *GameState) GetBoardLength() uint32 {
	if m != nil {
		return m.BoardLength
	}
	return 0
}

func (m *GameState) GetRemainingStones() []uint32 {
	if m != nil {
		return m.RemainingStones
	}
	return nil
}

func (m *GameState) GetRemainingCapstones() []uint32 {
	if m != nil {
		return m.RemainingCapstones
	}
	return nil
}

func (m *GameState) GetBoard() []*Pile {
	if m != nil {
		return m.Board
	}
	return nil
}

func init() {
	proto.RegisterEnum("tak.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("tak.PieceType", PieceType_name, PieceType_value)
	proto.RegisterType((*GameParameter)(nil), "tak.GameParameter")
	proto.RegisterType((*PlaceAction)(nil), "tak.PlaceAction")
	proto.RegisterType((*MoveAction)(nil), "tak.MoveAction")
	proto.RegisterType((*GameTurn)(nil), "tak.GameTurn")
	proto.RegisterType((*Piece)(nil), "tak.Piece")
	proto.RegisterType((*Pile)(nil), "tak.Pile")
	proto.RegisterType((*GameState)(nil), "tak.GameState")
}

func init() {
	proto.RegisterFile("tak.proto", fileDescriptor_28c71ac9511ea633)
}

var fileDescriptor_28c71ac9511ea633 = []byte{
	// 483 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xcf, 0x6f, 0xd3, 0x30,
	0x1c, 0xc5, 0xeb, 0x26, 0xa9, 0x9a, 0x6f, 0x7f, 0x2c, 0x73, 0x39, 0xe4, 0x46, 0x89, 0x40, 0x2a,
	0x15, 0x6a, 0xa5, 0x4e, 0x1c, 0x39, 0x74, 0x5b, 0x59, 0x91, 0x46, 0x1b, 0x39, 0x41, 0x48, 0x70,
	0x88, 0xbc, 0xc4, 0x2a, 0x51, 0x7e, 0x38, 0x4a, 0xcd, 0x58, 0x8e, 0xfc, 0x3d, 0xfc, 0x93, 0xc8,
	0x4e, 0xda, 0x88, 0x03, 0xd2, 0x8e, 0xdf, 0xcf, 0x7b, 0xb6, 0x9f, 0x9f, 0x65, 0x30, 0x05, 0x4d,
	0x16, 0x45, 0xc9, 0x05, 0xc7, 0x9a, 0xa0, 0x89, 0xb3, 0x82, 0xd1, 0x1d, 0xcd, 0x98, 0x4b, 0x4b,
	0x9a, 0x31, 0xc1, 0x4a, 0xfc, 0x0a, 0x86, 0x0f, 0x9c, 0x96, 0x51, 0x90, 0xb2, 0xfc, 0x20, 0x7e,
	0xd8, 0x68, 0x8a, 0x66, 0x23, 0x32, 0x50, 0xec, 0x5e, 0x21, 0xe7, 0x0a, 0x06, 0x6e, 0x4a, 0x43,
	0xb6, 0x0e, 0x45, 0xcc, 0x73, 0xfc, 0x1a, 0x8c, 0x22, 0x66, 0x21, 0x53, 0xd6, 0xf1, 0x6a, 0xbc,
	0x90, 0x47, 0xb8, 0x92, 0xf8, 0x55, 0xc1, 0x48, 0x2d, 0x3a, 0x2e, 0xc0, 0x67, 0xfe, 0x78, 0x5a,
	0xf3, 0x0e, 0xcc, 0x28, 0x2e, 0x99, 0x1a, 0xfe, 0x59, 0x77, 0x7b, 0xa2, 0xa4, 0x35, 0xe0, 0x17,
	0x60, 0x44, 0x25, 0x2f, 0x8e, 0x76, 0x77, 0xaa, 0xcd, 0x46, 0xa4, 0x1e, 0x9c, 0xdf, 0x08, 0xfa,
	0x32, 0xbb, 0xff, 0xb3, 0xcc, 0xf1, 0x10, 0xd0, 0x53, 0x93, 0x15, 0x3d, 0xc9, 0xa9, 0xb2, 0xbb,
	0xf5, 0x54, 0xe1, 0x19, 0x18, 0x85, 0xcc, 0x6b, 0x6b, 0x53, 0x34, 0x1b, 0xac, 0xac, 0x3a, 0x60,
	0x7b, 0x83, 0x6d, 0x87, 0xd4, 0x06, 0xfc, 0x06, 0xf4, 0x8c, 0x3f, 0x32, 0x5b, 0x57, 0xc6, 0x0b,
	0x65, 0x6c, 0x53, 0x6f, 0x3b, 0x44, 0xc9, 0xd7, 0x7d, 0xe8, 0xd5, 0xc4, 0xf9, 0x0e, 0x86, 0xba,
	0x29, 0x76, 0x40, 0x17, 0x55, 0xf1, 0xbf, 0x0e, 0x94, 0x86, 0x17, 0x30, 0x39, 0xb2, 0x90, 0xe7,
	0x51, 0x50, 0xa4, 0xb4, 0x62, 0x65, 0xc0, 0x7f, 0xe5, 0x2c, 0x52, 0x39, 0xfb, 0xe4, 0xb2, 0x96,
	0x5c, 0xa5, 0xec, 0xa5, 0xe0, 0xcc, 0x41, 0x77, 0xe3, 0x54, 0xee, 0xdd, 0x53, 0x1d, 0x1e, 0x6d,
	0x34, 0xd5, 0x66, 0x83, 0x15, 0xb4, 0xbb, 0x93, 0x46, 0x71, 0xfe, 0x20, 0x30, 0x65, 0x19, 0x9e,
	0xa0, 0x82, 0x3d, 0xe3, 0x11, 0xf1, 0x5b, 0xb0, 0x4a, 0x96, 0xd1, 0x38, 0x8f, 0xf3, 0x43, 0x70,
	0x14, 0x3c, 0x67, 0xa7, 0x7a, 0x2f, 0xce, 0xdc, 0x53, 0x18, 0x2f, 0x61, 0xd2, 0x5a, 0x43, 0x5a,
	0x34, 0x6e, 0x4d, 0xb9, 0xf1, 0x59, 0xba, 0x39, 0x29, 0xf8, 0x25, 0x18, 0xea, 0x28, 0x5b, 0x57,
	0x79, 0xcd, 0x26, 0x6f, 0xca, 0x48, 0xcd, 0xe7, 0xef, 0xc1, 0x3c, 0x3f, 0x34, 0x36, 0xc1, 0xd8,
	0xed, 0x89, 0xbf, 0xb5, 0x3a, 0xb8, 0x0f, 0xfa, 0x66, 0xed, 0xf9, 0x16, 0x92, 0xd0, 0xdb, 0x7f,
	0xf1, 0xb7, 0x56, 0x57, 0xc2, 0xaf, 0x1b, 0xcf, 0xb7, 0xb4, 0xf9, 0x07, 0x30, 0xcf, 0x9d, 0xe2,
	0x31, 0xc0, 0xc7, 0xfb, 0xb5, 0x1f, 0x78, 0xfe, 0x7e, 0xb7, 0xb1, 0x3a, 0x18, 0xc3, 0xd8, 0xf3,
	0xd7, 0xbb, 0xdb, 0x4f, 0xbb, 0xbb, 0x86, 0x21, 0x3c, 0x84, 0xfe, 0xcd, 0xda, 0xad, 0xa7, 0xee,
	0xf5, 0xe4, 0xdb, 0xa5, 0x60, 0x09, 0x0f, 0x0e, 0x34, 0x63, 0xcb, 0x22, 0x39, 0x2c, 0x05, 0x4d,
	0x1e, 0x7a, 0xea, 0x33, 0x5c, 0xfd, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xda, 0x57, 0xfa, 0xb6, 0x19,
	0x03, 0x00, 0x00,
}
